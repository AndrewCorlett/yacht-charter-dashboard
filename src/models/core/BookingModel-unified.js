/**
 * Unified Booking Model - Single Table Design for Yacht Charter Bookings
 * 
 * Comprehensive data model for the unified bookings table that consolidates
 * all booking, customer, yacht, and document tracking information.
 * Optimized for Supabase single-table architecture with embedded customer data.
 * 
 * @author AI Agent
 * @created 2025-06-26
 * @version 2.0.0 - Unified Table Architecture
 */

import { format, parseISO, isValid, isBefore, isAfter } from 'date-fns'

/**
 * Booking status enumeration matching database ENUM
 */
export const BookingStatus = {
  TENTATIVE: 'tentative',
  CONFIRMED: 'confirmed',
  COMPLETED: 'completed',
  CANCELLED: 'cancelled'
}

/**
 * Charter type enumeration matching database ENUM
 */
export const CharterType = {
  BAREBOAT: 'bareboat',
  SKIPPERED_CHARTER: 'skippered charter'
}

/**
 * Payment status enumeration matching database ENUM
 */
export const PaymentStatus = {
  PENDING: 'pending',
  DEPOSIT_PAID: 'deposit_paid',
  FULL_PAYMENT: 'full_payment',
  REFUNDED: 'refunded'
}

/**
 * Document types for tracking generation/download status
 */
export const DocumentTypes = {
  CONTRACT: 'contract',
  DEPOSIT_INVOICE: 'deposit_invoice', 
  DEPOSIT_RECEIPT: 'deposit_receipt',
  BALANCE_INVOICE: 'balance_invoice',
  BALANCE_RECEIPT: 'balance_receipt',
  HANDOVER_NOTES: 'handover_notes'
}

/**
 * Unified Booking Model Class
 * 
 * Represents a complete yacht booking with all embedded customer information,
 * yacht details, status tracking, and document management in a single entity.
 */
export class BookingModel {
  /**
   * Create a new BookingModel instance
   * 
   * @param {Object} data - Initial booking data (from database or form)
   */
  constructor(data = {}) {
    // === CORE IDENTIFICATION ===
    this.id = data.id || null // Will be auto-generated by database
    this.booking_number = data.booking_number || null // Auto-generated by database
    this.ical_uid = data.ical_uid || null // Auto-generated by database
    
    // === EMBEDDED CUSTOMER INFORMATION ===
    this.customer_first_name = data.customer_first_name || data.firstName || ''
    this.customer_surname = data.customer_surname || data.surname || ''
    this.customer_email = data.customer_email || data.email || ''
    this.customer_phone = data.customer_phone || data.phone || ''
    
    // Customer address (embedded for performance)
    this.customer_street = data.customer_street || data.street || ''
    this.customer_city = data.customer_city || data.city || ''
    this.customer_postcode = data.customer_postcode || data.postcode || ''
    this.customer_country = data.customer_country || data.country || 'United Kingdom'
    
    // === YACHT INFORMATION (DENORMALIZED) ===
    this.yacht_id = data.yacht_id || data.yacht || ''
    this.yacht_name = data.yacht_name || '' // Cached from yacht table
    this.yacht_type = data.yacht_type || '' // Cached from yacht table
    this.yacht_location = data.yacht_location || '' // Cached from yacht table
    
    // === BOOKING DETAILS ===
    this.charter_type = data.charter_type || data.tripType || CharterType.BAREBOAT
    this.start_date = this._parseDate(data.start_date || data.startDate)
    this.end_date = this._parseDate(data.end_date || data.endDate)
    this.port_of_departure = data.port_of_departure || data.portOfDeparture || ''
    this.port_of_arrival = data.port_of_arrival || data.portOfArrival || ''
    
    // === STATUS TRACKING ===
    // High-level statuses
    this.booking_status = data.booking_status || BookingStatus.TENTATIVE
    this.payment_status = data.payment_status || PaymentStatus.PENDING
    
    // Detailed status flags (from frontend statusData)
    this.booking_confirmed = Boolean(data.booking_confirmed || data.bookingConfirmed)
    this.deposit_paid = Boolean(data.deposit_paid || data.depositPaid)
    this.contract_sent = Boolean(data.contract_sent || data.contractSent)
    this.contract_signed = Boolean(data.contract_signed || data.contractSigned)
    this.deposit_invoice_sent = Boolean(data.deposit_invoice_sent || data.depositInvoiceSent)
    this.receipt_issued = Boolean(data.receipt_issued || data.receiptIssued)
    
    // === FINANCIAL INFORMATION ===
    this.base_rate = this._parseDecimal(data.base_rate)
    this.total_amount = this._parseDecimal(data.total_amount)
    this.deposit_amount = this._parseDecimal(data.deposit_amount)
    this.balance_due = this._parseDecimal(data.balance_due)
    
    // === FILE MANAGEMENT ===
    this.crew_experience_file_name = data.crew_experience_file_name || data.crewExperienceFile?.name || null
    this.crew_experience_file_url = data.crew_experience_file_url || data.crewExperienceFile?.url || null
    this.crew_experience_file_size = data.crew_experience_file_size || data.crewExperienceFile?.size || null
    
    // === DOCUMENT GENERATION TRACKING ===
    // Contract
    this.contract_generated_at = this._parseDateTime(data.contract_generated_at)
    this.contract_downloaded_at = this._parseDateTime(data.contract_downloaded_at)
    this.contract_updated_at = this._parseDateTime(data.contract_updated_at)
    
    // Deposit Invoice
    this.deposit_invoice_generated_at = this._parseDateTime(data.deposit_invoice_generated_at)
    this.deposit_invoice_downloaded_at = this._parseDateTime(data.deposit_invoice_downloaded_at)
    this.deposit_invoice_updated_at = this._parseDateTime(data.deposit_invoice_updated_at)
    
    // Deposit Receipt
    this.deposit_receipt_generated_at = this._parseDateTime(data.deposit_receipt_generated_at)
    this.deposit_receipt_downloaded_at = this._parseDateTime(data.deposit_receipt_downloaded_at)
    this.deposit_receipt_updated_at = this._parseDateTime(data.deposit_receipt_updated_at)
    
    // Balance Invoice
    this.balance_invoice_generated_at = this._parseDateTime(data.balance_invoice_generated_at)
    this.balance_invoice_downloaded_at = this._parseDateTime(data.balance_invoice_downloaded_at)
    this.balance_invoice_updated_at = this._parseDateTime(data.balance_invoice_updated_at)
    
    // Balance Receipt
    this.balance_receipt_generated_at = this._parseDateTime(data.balance_receipt_generated_at)
    this.balance_receipt_downloaded_at = this._parseDateTime(data.balance_receipt_downloaded_at)
    this.balance_receipt_updated_at = this._parseDateTime(data.balance_receipt_updated_at)
    
    // Handover Notes
    this.handover_notes_generated_at = this._parseDateTime(data.handover_notes_generated_at)
    this.handover_notes_downloaded_at = this._parseDateTime(data.handover_notes_downloaded_at)
    this.handover_notes_updated_at = this._parseDateTime(data.handover_notes_updated_at)
    
    // === ADDITIONAL INFORMATION ===
    this.special_requirements = data.special_requirements || ''
    this.notes = data.notes || ''
    
    // === AUDIT FIELDS ===
    this.created_at = this._parseDateTime(data.created_at) || new Date()
    this.updated_at = this._parseDateTime(data.updated_at) || new Date()
    this.created_by = data.created_by || 'system'
    this.updated_by = data.updated_by || 'system'
    
    // Change history (managed by database triggers)
    this.change_history = data.change_history || []
    
    // Validation errors storage
    this._errors = new Map()
  }

  /**
   * Parse date input (handles both Date objects and strings)
   * @param {string|Date|null} value - Input date
   * @returns {Date|null} Parsed date or null
   * @private
   */
  _parseDate(value) {
    if (!value) return null
    if (value instanceof Date) return value
    if (typeof value === 'string') {
      // Handle both full datetime and date-only strings
      const parsed = parseISO(value.includes('T') ? value : value + 'T00:00:00')
      return isValid(parsed) ? parsed : null
    }
    return null
  }

  /**
   * Parse datetime input with timezone handling
   * @param {string|Date|null} value - Input datetime
   * @returns {Date|null} Parsed datetime or null
   * @private
   */
  _parseDateTime(value) {
    if (!value) return null
    if (value instanceof Date) return value
    if (typeof value === 'string') {
      const parsed = parseISO(value)
      return isValid(parsed) ? parsed : null
    }
    return null
  }

  /**
   * Parse and validate decimal input
   * @param {string|number|null} value - Input decimal
   * @returns {number|null} Parsed decimal or null
   * @private
   */
  _parseDecimal(value) {
    if (value === null || value === undefined || value === '') return null
    const parsed = parseFloat(value)
    return isNaN(parsed) ? null : parsed
  }

  /**
   * Validate all booking data according to business rules
   * @returns {boolean} True if valid, false otherwise
   */
  validate() {
    this._errors.clear()

    // === REQUIRED FIELD VALIDATION ===
    if (!this.customer_first_name?.trim()) {
      this._errors.set('customer_first_name', 'First name is required')
    }

    if (!this.customer_surname?.trim()) {
      this._errors.set('customer_surname', 'Surname is required')
    }

    if (!this.customer_email?.trim()) {
      this._errors.set('customer_email', 'Email is required')
    } else if (!this._isValidEmail(this.customer_email)) {
      this._errors.set('customer_email', 'Invalid email format')
    }

    if (!this.yacht_id?.trim()) {
      this._errors.set('yacht_id', 'Yacht selection is required')
    }

    // === DATE VALIDATION ===
    if (!this.start_date) {
      this._errors.set('start_date', 'Start date is required')
    }

    if (!this.end_date) {
      this._errors.set('end_date', 'End date is required')
    }

    if (this.start_date && this.end_date) {
      if (!isBefore(this.start_date, this.end_date) && 
          format(this.start_date, 'yyyy-MM-dd') !== format(this.end_date, 'yyyy-MM-dd')) {
        this._errors.set('end_date', 'End date must be after start date')
      }
    }

    // === ENUM VALIDATION ===
    if (!Object.values(CharterType).includes(this.charter_type)) {
      this._errors.set('charter_type', 'Invalid charter type')
    }

    if (!Object.values(BookingStatus).includes(this.booking_status)) {
      this._errors.set('booking_status', 'Invalid booking status')
    }

    if (!Object.values(PaymentStatus).includes(this.payment_status)) {
      this._errors.set('payment_status', 'Invalid payment status')
    }

    // === FINANCIAL VALIDATION ===
    if (this.base_rate !== null && this.base_rate < 0) {
      this._errors.set('base_rate', 'Base rate cannot be negative')
    }

    if (this.total_amount !== null && this.total_amount < 0) {
      this._errors.set('total_amount', 'Total amount cannot be negative')
    }

    if (this.deposit_amount !== null && this.deposit_amount < 0) {
      this._errors.set('deposit_amount', 'Deposit amount cannot be negative')
    }

    if (this.total_amount !== null && this.deposit_amount !== null && 
        this.deposit_amount > this.total_amount) {
      this._errors.set('deposit_amount', 'Deposit cannot exceed total amount')
    }

    // === PHONE VALIDATION (if provided) ===
    if (this.customer_phone && !this._isValidPhone(this.customer_phone)) {
      this._errors.set('customer_phone', 'Invalid phone number format')
    }

    // === FILE VALIDATION ===
    if (this.crew_experience_file_size !== null && this.crew_experience_file_size <= 0) {
      this._errors.set('crew_experience_file_size', 'File size must be positive')
    }

    return this._errors.size === 0
  }

  /**
   * Validate email format
   * @param {string} email - Email to validate
   * @returns {boolean} True if valid
   * @private
   */
  _isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return emailRegex.test(email)
  }

  /**
   * Validate phone number format (basic international format)
   * @param {string} phone - Phone to validate
   * @returns {boolean} True if valid
   * @private
   */
  _isValidPhone(phone) {
    const phoneRegex = /^[\+]?[1-9][\d]{0,15}$/
    const cleaned = phone.replace(/[\s\-\(\)]/g, '')
    return phoneRegex.test(cleaned) && cleaned.length >= 10
  }

  /**
   * Get all validation errors
   * @returns {Object} Object with field names as keys and error messages as values
   */
  getErrors() {
    return Object.fromEntries(this._errors)
  }

  /**
   * Get specific field error
   * @param {string} field - Field name
   * @returns {string|null} Error message or null
   */
  getError(field) {
    return this._errors.get(field) || null
  }

  /**
   * Check if booking has any validation errors
   * @returns {boolean} True if there are errors
   */
  hasErrors() {
    return this._errors.size > 0
  }

  /**
   * Update booking data and trigger validation
   * @param {Object} updates - Fields to update
   * @returns {boolean} True if update was successful and valid
   */
  update(updates) {
    Object.keys(updates).forEach(key => {
      if (key in this) {
        if (key.includes('_date') || key.includes('_at')) {
          this[key] = this._parseDateTime(updates[key])
        } else if (key.includes('amount') || key.includes('rate') || key.includes('size')) {
          this[key] = this._parseDecimal(updates[key])
        } else {
          this[key] = updates[key]
        }
      }
    })

    this.updated_at = new Date()
    return this.validate()
  }

  /**
   * Convert booking to database-ready format (unified table structure)
   * @returns {Object} Database-formatted booking data
   */
  toDatabase() {
    return {
      // Core identification (id, booking_number, ical_uid auto-generated)
      id: this.id,
      booking_number: this.booking_number,
      ical_uid: this.ical_uid,
      
      // Embedded customer information
      customer_first_name: this.customer_first_name,
      customer_surname: this.customer_surname,
      customer_email: this.customer_email,
      customer_phone: this.customer_phone,
      customer_street: this.customer_street,
      customer_city: this.customer_city,
      customer_postcode: this.customer_postcode,
      customer_country: this.customer_country,
      
      // Yacht information (denormalized)
      yacht_id: this.yacht_id,
      yacht_name: this.yacht_name,
      yacht_type: this.yacht_type,
      yacht_location: this.yacht_location,
      
      // Booking details
      charter_type: this.charter_type,
      start_date: this.start_date ? format(this.start_date, 'yyyy-MM-dd') : null,
      end_date: this.end_date ? format(this.end_date, 'yyyy-MM-dd') : null,
      port_of_departure: this.port_of_departure,
      port_of_arrival: this.port_of_arrival,
      
      // Status tracking
      booking_status: this.booking_status,
      payment_status: this.payment_status,
      booking_confirmed: this.booking_confirmed,
      deposit_paid: this.deposit_paid,
      contract_sent: this.contract_sent,
      contract_signed: this.contract_signed,
      deposit_invoice_sent: this.deposit_invoice_sent,
      receipt_issued: this.receipt_issued,
      
      // Financial information
      base_rate: this.base_rate,
      total_amount: this.total_amount,
      deposit_amount: this.deposit_amount,
      balance_due: this.balance_due,
      
      // File management
      crew_experience_file_name: this.crew_experience_file_name,
      crew_experience_file_url: this.crew_experience_file_url,
      crew_experience_file_size: this.crew_experience_file_size,
      
      // Document tracking timestamps
      contract_generated_at: this.contract_generated_at?.toISOString(),
      contract_downloaded_at: this.contract_downloaded_at?.toISOString(),
      contract_updated_at: this.contract_updated_at?.toISOString(),
      
      deposit_invoice_generated_at: this.deposit_invoice_generated_at?.toISOString(),
      deposit_invoice_downloaded_at: this.deposit_invoice_downloaded_at?.toISOString(),
      deposit_invoice_updated_at: this.deposit_invoice_updated_at?.toISOString(),
      
      deposit_receipt_generated_at: this.deposit_receipt_generated_at?.toISOString(),
      deposit_receipt_downloaded_at: this.deposit_receipt_downloaded_at?.toISOString(),
      deposit_receipt_updated_at: this.deposit_receipt_updated_at?.toISOString(),
      
      balance_invoice_generated_at: this.balance_invoice_generated_at?.toISOString(),
      balance_invoice_downloaded_at: this.balance_invoice_downloaded_at?.toISOString(),
      balance_invoice_updated_at: this.balance_invoice_updated_at?.toISOString(),
      
      balance_receipt_generated_at: this.balance_receipt_generated_at?.toISOString(),
      balance_receipt_downloaded_at: this.balance_receipt_downloaded_at?.toISOString(),
      balance_receipt_updated_at: this.balance_receipt_updated_at?.toISOString(),
      
      handover_notes_generated_at: this.handover_notes_generated_at?.toISOString(),
      handover_notes_downloaded_at: this.handover_notes_downloaded_at?.toISOString(),
      handover_notes_updated_at: this.handover_notes_updated_at?.toISOString(),
      
      // Additional information
      special_requirements: this.special_requirements,
      notes: this.notes,
      
      // Audit fields (updated_at handled by database trigger)
      created_at: this.created_at?.toISOString(),
      updated_at: this.updated_at?.toISOString(),
      created_by: this.created_by,
      updated_by: this.updated_by
    }
  }

  /**
   * Convert booking to frontend-friendly format (for forms)
   * @returns {Object} Frontend-formatted booking data
   */
  toFrontend() {
    return {
      // Core identification
      id: this.id,
      bookingNumber: this.booking_number,
      
      // Customer information (mapped to form field names)
      firstName: this.customer_first_name,
      surname: this.customer_surname,
      email: this.customer_email,
      phone: this.customer_phone,
      street: this.customer_street,
      city: this.customer_city,
      postcode: this.customer_postcode,
      country: this.customer_country,
      
      // Yacht information
      yacht: this.yacht_id,
      yachtName: this.yacht_name,
      yachtType: this.yacht_type,
      yachtLocation: this.yacht_location,
      
      // Booking details (mapped to form field names)
      tripType: this.charter_type,
      startDate: this.start_date ? format(this.start_date, 'yyyy-MM-dd') : '',
      endDate: this.end_date ? format(this.end_date, 'yyyy-MM-dd') : '',
      portOfDeparture: this.port_of_departure,
      portOfArrival: this.port_of_arrival,
      
      // Status tracking (mapped to form field names)
      bookingStatus: this.booking_status,
      paymentStatus: this.payment_status,
      
      // Status flags (for frontend statusData)
      status: {
        bookingConfirmed: this.booking_confirmed,
        depositPaid: this.deposit_paid,
        contractSent: this.contract_sent,
        contractSigned: this.contract_signed,
        depositInvoiceSent: this.deposit_invoice_sent,
        receiptIssued: this.receipt_issued
      },
      
      // Financial information
      baseRate: this.base_rate,
      totalAmount: this.total_amount,
      depositAmount: this.deposit_amount,
      balanceDue: this.balance_due,
      
      // File information (mapped for FileUpload component)
      crewExperienceFile: this.crew_experience_file_name ? {
        name: this.crew_experience_file_name,
        url: this.crew_experience_file_url,
        size: this.crew_experience_file_size
      } : null,
      
      // Document states (for frontend documentStates)
      documentStates: {
        'Contract': {
          generated: Boolean(this.contract_generated_at),
          downloaded: Boolean(this.contract_downloaded_at),
          updated: Boolean(this.contract_updated_at)
        },
        'Deposit Invoice': {
          generated: Boolean(this.deposit_invoice_generated_at),
          downloaded: Boolean(this.deposit_invoice_downloaded_at),
          updated: Boolean(this.deposit_invoice_updated_at)
        },
        'Deposit Receipt': {
          generated: Boolean(this.deposit_receipt_generated_at),
          downloaded: Boolean(this.deposit_receipt_downloaded_at),
          updated: Boolean(this.deposit_receipt_updated_at)
        },
        'Remaining Balance Invoice': {
          generated: Boolean(this.balance_invoice_generated_at),
          downloaded: Boolean(this.balance_invoice_downloaded_at),
          updated: Boolean(this.balance_invoice_updated_at)
        },
        'Remaining Balance Receipt': {
          generated: Boolean(this.balance_receipt_generated_at),
          downloaded: Boolean(this.balance_receipt_downloaded_at),
          updated: Boolean(this.balance_receipt_updated_at)
        },
        'Hand-over Notes': {
          generated: Boolean(this.handover_notes_generated_at),
          downloaded: Boolean(this.handover_notes_downloaded_at),
          updated: Boolean(this.handover_notes_updated_at)
        }
      },
      
      // Additional information
      specialRequirements: this.special_requirements,
      notes: this.notes,
      
      // Metadata
      createdAt: this.created_at,
      updatedAt: this.updated_at
    }
  }

  /**
   * Get full customer name
   * @returns {string} Full customer name
   */
  getCustomerFullName() {
    return `${this.customer_first_name} ${this.customer_surname}`.trim()
  }

  /**
   * Get booking duration in days
   * @returns {number} Duration in days
   */
  getDurationDays() {
    if (!this.start_date || !this.end_date) return 0
    const diffTime = Math.abs(this.end_date - this.start_date)
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24))
  }

  /**
   * Check if booking is active (not cancelled or completed)
   * @returns {boolean} True if active
   */
  isActive() {
    return ![BookingStatus.CANCELLED, BookingStatus.COMPLETED].includes(this.booking_status)
  }

  /**
   * Check if booking is in the past
   * @returns {boolean} True if past booking
   */
  isPast() {
    if (!this.end_date) return false
    return isBefore(this.end_date, new Date())
  }

  /**
   * Check if booking is current (ongoing)
   * @returns {boolean} True if currently active
   */
  isCurrent() {
    if (!this.start_date || !this.end_date) return false
    const now = new Date()
    return !isBefore(now, this.start_date) && isBefore(now, this.end_date)
  }

  /**
   * Check if booking is future
   * @returns {boolean} True if future booking
   */
  isFuture() {
    if (!this.start_date) return false
    return isAfter(this.start_date, new Date())
  }

  /**
   * Mark a document as generated
   * @param {string} documentType - Type of document (from DocumentTypes)
   */
  markDocumentGenerated(documentType) {
    const timestamp = new Date()
    switch (documentType) {
      case DocumentTypes.CONTRACT:
        this.contract_generated_at = timestamp
        break
      case DocumentTypes.DEPOSIT_INVOICE:
        this.deposit_invoice_generated_at = timestamp
        break
      case DocumentTypes.DEPOSIT_RECEIPT:
        this.deposit_receipt_generated_at = timestamp
        break
      case DocumentTypes.BALANCE_INVOICE:
        this.balance_invoice_generated_at = timestamp
        break
      case DocumentTypes.BALANCE_RECEIPT:
        this.balance_receipt_generated_at = timestamp
        break
      case DocumentTypes.HANDOVER_NOTES:
        this.handover_notes_generated_at = timestamp
        break
    }
    this.updated_at = timestamp
  }

  /**
   * Mark a document as downloaded
   * @param {string} documentType - Type of document (from DocumentTypes)
   */
  markDocumentDownloaded(documentType) {
    const timestamp = new Date()
    switch (documentType) {
      case DocumentTypes.CONTRACT:
        this.contract_downloaded_at = timestamp
        break
      case DocumentTypes.DEPOSIT_INVOICE:
        this.deposit_invoice_downloaded_at = timestamp
        break
      case DocumentTypes.DEPOSIT_RECEIPT:
        this.deposit_receipt_downloaded_at = timestamp
        break
      case DocumentTypes.BALANCE_INVOICE:
        this.balance_invoice_downloaded_at = timestamp
        break
      case DocumentTypes.BALANCE_RECEIPT:
        this.balance_receipt_downloaded_at = timestamp
        break
      case DocumentTypes.HANDOVER_NOTES:
        this.handover_notes_downloaded_at = timestamp
        break
    }
    this.updated_at = timestamp
  }

  /**
   * Create BookingModel from database record
   * @param {Object} dbRecord - Database record from unified bookings table
   * @returns {BookingModel} New booking instance
   */
  static fromDatabase(dbRecord) {
    return new BookingModel(dbRecord)
  }

  /**
   * Create BookingModel from frontend form data
   * @param {Object} formData - Form data from BookingPanel
   * @param {Object} statusData - Status data from BookingPanel
   * @returns {BookingModel} New booking instance
   */
  static fromFrontend(formData, statusData = {}) {
    const mappedData = {
      // Map frontend form fields to database fields
      customer_first_name: formData.firstName,
      customer_surname: formData.surname,
      customer_email: formData.email,
      customer_phone: formData.phone,
      customer_street: formData.street,
      customer_city: formData.city,
      customer_postcode: formData.postcode,
      customer_country: formData.country,
      
      yacht_id: formData.yacht,
      charter_type: formData.tripType,
      start_date: formData.startDate,
      end_date: formData.endDate,
      port_of_departure: formData.portOfDeparture,
      port_of_arrival: formData.portOfArrival,
      
      // Map status data
      booking_confirmed: statusData.bookingConfirmed,
      deposit_paid: statusData.depositPaid,
      contract_sent: statusData.contractSent,
      contract_signed: statusData.contractSigned,
      deposit_invoice_sent: statusData.depositInvoiceSent,
      receipt_issued: statusData.receiptIssued,
      
      // File data
      crew_experience_file_name: formData.crewExperienceFile?.name,
      crew_experience_file_url: formData.crewExperienceFile?.url,
      crew_experience_file_size: formData.crewExperienceFile?.size,
      
      // Additional fields
      special_requirements: formData.specialRequirements,
      notes: formData.notes
    }

    return new BookingModel(mappedData)
  }

  /**
   * Create a copy of the booking with new ID (for cloning)
   * @returns {BookingModel} New booking instance
   */
  clone() {
    const data = this.toDatabase()
    delete data.id
    delete data.booking_number
    delete data.ical_uid
    delete data.created_at
    data.booking_status = BookingStatus.TENTATIVE
    return new BookingModel(data)
  }
}

export default BookingModel