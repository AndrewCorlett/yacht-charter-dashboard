/**
 * Add Pricing Rule Modal Component
 * 
 * Purpose: Modal form for creating new yacht pricing rules
 * Supports daily rates, seasonal pricing, and special offers
 * 
 * @author AI Agent
 * @created 2025-06-24
 */

import { useState } from 'react'
import Modal from '../../common/Modal'
import { ActionButton } from '../AdminConfigLayout'

function AddPricingRule({ isOpen, onClose, onSave }) {
  const [formData, setFormData] = useState({
    yachtId: '',
    ruleType: 'base',
    rateType: 'daily',
    rate: '',
    currency: 'EUR',
    startDate: '',
    endDate: '',
    minHours: '4',
    priority: '1',
    isActive: true
  })

  const [errors, setErrors] = useState({})
  const [isSubmitting, setIsSubmitting] = useState(false)

  const yachts = [
    { id: 'spectre', name: 'Spectre' },
    { id: 'diskdrive', name: 'Disk Drive' },
    { id: 'arriva', name: 'Arriva' },
    { id: 'zambada', name: 'Zambada' },
    { id: 'melba', name: 'Melba So' }
  ]

  const ruleTypes = [
    { id: 'base', name: 'Base Rate', description: 'Standard daily/hourly pricing' },
    { id: 'seasonal', name: 'Seasonal', description: 'Seasonal rate adjustments' },
    { id: 'special', name: 'Special Offer', description: 'Promotional pricing' }
  ]

  const currencies = ['EUR', 'USD', 'GBP']

  const validateForm = () => {
    const newErrors = {}

    if (!formData.yachtId) newErrors.yachtId = 'Yacht is required'
    if (!formData.rate || isNaN(formData.rate) || parseFloat(formData.rate) <= 0) {
      newErrors.rate = 'Valid rate is required'
    }
    if (!formData.startDate) newErrors.startDate = 'Start date is required'
    if (!formData.endDate) newErrors.endDate = 'End date is required'
    if (formData.startDate && formData.endDate && formData.startDate > formData.endDate) {
      newErrors.endDate = 'End date must be after start date'
    }
    if (!formData.minHours || isNaN(formData.minHours) || parseInt(formData.minHours) < 1) {
      newErrors.minHours = 'Minimum hours must be at least 1'
    }
    if (!formData.priority || isNaN(formData.priority) || parseInt(formData.priority) < 1) {
      newErrors.priority = 'Priority must be at least 1'
    }

    setErrors(newErrors)
    return Object.keys(newErrors).length === 0
  }

  const handleSubmit = async (e) => {
    e.preventDefault()
    
    if (!validateForm()) return

    setIsSubmitting(true)
    try {
      const yachtName = yachts.find(y => y.id === formData.yachtId)?.name || formData.yachtId
      
      const pricingRule = {
        id: Date.now(), // In real app, this would be generated by backend
        yachtName,
        ...formData,
        rate: parseFloat(formData.rate),
        minHours: parseInt(formData.minHours),
        priority: parseInt(formData.priority)
      }

      await onSave(pricingRule)
      handleClose()
    } catch (error) {
      setErrors({ submit: 'Failed to save pricing rule. Please try again.' })
    } finally {
      setIsSubmitting(false)
    }
  }

  const handleClose = () => {
    setFormData({
      yachtId: '',
      ruleType: 'base',
      rateType: 'daily',
      rate: '',
      currency: 'EUR',
      startDate: '',
      endDate: '',
      minHours: '4',
      priority: '1',
      isActive: true
    })
    setErrors({})
    setIsSubmitting(false)
    onClose()
  }

  const handleInputChange = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }))
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: '' }))
    }
  }

  if (!isOpen) return null

  return (
    <Modal onClose={handleClose} title="Add Pricing Rule">
      <form onSubmit={handleSubmit} className="space-y-6">
        {errors.submit && (
          <div className="bg-red-50 border border-red-200 rounded-md p-4">
            <div className="text-red-800">{errors.submit}</div>
          </div>
        )}

        {/* Yacht Selection */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Yacht *
          </label>
          <select
            value={formData.yachtId}
            onChange={(e) => handleInputChange('yachtId', e.target.value)}
            className={`w-full border rounded-md px-3 py-2 ${
              errors.yachtId ? 'border-red-500' : 'border-gray-300'
            }`}
          >
            <option value="">Select a yacht</option>
            {yachts.map(yacht => (
              <option key={yacht.id} value={yacht.id}>{yacht.name}</option>
            ))}
          </select>
          {errors.yachtId && (
            <p className="mt-1 text-sm text-red-600">{errors.yachtId}</p>
          )}
        </div>

        {/* Rule Type */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Rule Type
          </label>
          <div className="space-y-2">
            {ruleTypes.map(type => (
              <label key={type.id} className="flex items-start space-x-3">
                <input
                  type="radio"
                  name="ruleType"
                  value={type.id}
                  checked={formData.ruleType === type.id}
                  onChange={(e) => handleInputChange('ruleType', e.target.value)}
                  className="mt-1"
                />
                <div>
                  <div className="font-medium text-gray-900">{type.name}</div>
                  <div className="text-sm text-gray-500">{type.description}</div>
                </div>
              </label>
            ))}
          </div>
        </div>

        {/* Rate and Currency */}
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Rate *
            </label>
            <input
              type="number"
              step="0.01"
              min="0"
              value={formData.rate}
              onChange={(e) => handleInputChange('rate', e.target.value)}
              placeholder="2500.00"
              className={`w-full border rounded-md px-3 py-2 ${
                errors.rate ? 'border-red-500' : 'border-gray-300'
              }`}
            />
            {errors.rate && (
              <p className="mt-1 text-sm text-red-600">{errors.rate}</p>
            )}
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Currency
            </label>
            <select
              value={formData.currency}
              onChange={(e) => handleInputChange('currency', e.target.value)}
              className="w-full border border-gray-300 rounded-md px-3 py-2"
            >
              {currencies.map(currency => (
                <option key={currency} value={currency}>{currency}</option>
              ))}
            </select>
          </div>
        </div>

        {/* Rate Type */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Rate Type
          </label>
          <select
            value={formData.rateType}
            onChange={(e) => handleInputChange('rateType', e.target.value)}
            className="w-full border border-gray-300 rounded-md px-3 py-2"
          >
            <option value="daily">Daily Rate</option>
            <option value="hourly">Hourly Rate</option>
          </select>
        </div>

        {/* Date Range */}
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Start Date *
            </label>
            <input
              type="date"
              value={formData.startDate}
              onChange={(e) => handleInputChange('startDate', e.target.value)}
              className={`w-full border rounded-md px-3 py-2 ${
                errors.startDate ? 'border-red-500' : 'border-gray-300'
              }`}
            />
            {errors.startDate && (
              <p className="mt-1 text-sm text-red-600">{errors.startDate}</p>
            )}
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              End Date *
            </label>
            <input
              type="date"
              value={formData.endDate}
              onChange={(e) => handleInputChange('endDate', e.target.value)}
              className={`w-full border rounded-md px-3 py-2 ${
                errors.endDate ? 'border-red-500' : 'border-gray-300'
              }`}
            />
            {errors.endDate && (
              <p className="mt-1 text-sm text-red-600">{errors.endDate}</p>
            )}
          </div>
        </div>

        {/* Additional Settings */}
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Minimum Hours *
            </label>
            <input
              type="number"
              min="1"
              value={formData.minHours}
              onChange={(e) => handleInputChange('minHours', e.target.value)}
              className={`w-full border rounded-md px-3 py-2 ${
                errors.minHours ? 'border-red-500' : 'border-gray-300'
              }`}
            />
            {errors.minHours && (
              <p className="mt-1 text-sm text-red-600">{errors.minHours}</p>
            )}
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Priority *
            </label>
            <input
              type="number"
              min="1"
              value={formData.priority}
              onChange={(e) => handleInputChange('priority', e.target.value)}
              className={`w-full border rounded-md px-3 py-2 ${
                errors.priority ? 'border-red-500' : 'border-gray-300'
              }`}
            />
            <p className="mt-1 text-xs text-gray-500">
              Higher numbers take precedence
            </p>
            {errors.priority && (
              <p className="mt-1 text-sm text-red-600">{errors.priority}</p>
            )}
          </div>
        </div>

        {/* Active Status */}
        <div>
          <label className="flex items-center space-x-3">
            <input
              type="checkbox"
              checked={formData.isActive}
              onChange={(e) => handleInputChange('isActive', e.target.checked)}
              className="rounded"
            />
            <span className="text-sm font-medium text-gray-700">
              Active (rule will be applied immediately)
            </span>
          </label>
        </div>

        {/* Form Actions */}
        <div className="flex items-center justify-end space-x-3 pt-6 border-t border-gray-200">
          <ActionButton
            variant="outline"
            onClick={handleClose}
            disabled={isSubmitting}
          >
            Cancel
          </ActionButton>
          <ActionButton
            type="submit"
            variant="primary"
            disabled={isSubmitting}
          >
            {isSubmitting ? 'Saving...' : 'Save Pricing Rule'}
          </ActionButton>
        </div>
      </form>
    </Modal>
  )
}

export default AddPricingRule